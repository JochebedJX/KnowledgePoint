# C语言和C++关键字总结

------

   * [C语言和C  关键字总结](#c语言和c关键字总结)
      * [一、auto](#一auto)
      * [二、struct](#二struct)
      * 

|        关键字        |                             意义                             | C/C++ |
| :------------------: | :----------------------------------------------------------: | :---: |
|       **auto**       |  声明自动变量，缺省时编译器一般默认为auto（详细讲解见下方）  | C/C++ |
|         int          |                         声明整型变量                         | C/C++ |
|        double        |                        声明双精度变量                        | C/C++ |
|         long         |                        声明长整型变量                        | C/C++ |
|         char         |                        声明字符型变量                        | C/C++ |
|        float         |                        声明浮点型变量                        | C/C++ |
|        short         |                        声明短整型变量                        | C/C++ |
|        signed        |                      声明有符号类型变量                      | C/C++ |
|       unsigned       |                      声明无符号类型变量                      | C/C++ |
|      **struct**      |               声明结构体变量（详细讲解见下方）               | C/C++ |
|        union         |                       声明联合数据类型                       | C/C++ |
|         enum         |                         声明枚举类型                         | C/C++ |
|      **static**      |                声明静态变量（详细讲解见下方）                | C/C++ |
|        switch        |                         用于开关语句                         | C/C++ |
|         case         |                         开关语句分支                         | C/C++ |
|       default        |                    开关语句中的“其他”分支                    | C/C++ |
|        break         |                         跳出当前循环                         | C/C++ |
|     **register**     |               声明寄存器变量（详细讲解见下方）               | C/C++ |
|      **const**       |                声明只读变量（详细讲解见下方）                | C/C++ |
|     **volatile**     |     说明变量在程序执行中可被隐含地改变（详细讲解见下方）     | C/C++ |
|       typedef        |            用以给数据类型取别名(当然还有其他作用)            | C/C++ |
|      **extern**      | 声明变量是在其他文件正声明(也可以看做是引用变量)（详细讲解见下方） | C/C++ |
|        return        |           子程序返回语句(可以带参数，也可不带参数)           | C/C++ |
|         void         |           声明函数无返回值或无参数，声明空类型指针           | C/C++ |
|       continue       |                 结束当前循环，开始下一轮循环                 | C/C++ |
|          do          |                       循环语句的循环体                       | C/C++ |
|        while         |                      循环语句的循环条件                      | C/C++ |
|          if          |                           条件语句                           | C/C++ |
|         else         |                 条件语句否定分支(与if 连用)                  | C/C++ |
|         for          |                 一种循环语句(可意会不可言传)                 | C/C++ |
|         goto         |                        无条件跳转语句                        | C/C++ |
|      **sizeof**      |          计算对象所占内存空间大小（详细讲解见下方）          | C/C++ |
|         asm          |       asm (指令字符串)：允许在 C++ 程序中嵌入汇编代码        |  C++  |
|         bool         | C++ 中的基本数据结构，其值可选为 true（真）或者 false（假）  |  C++  |
|       **new**        |        new（新建）用于新建一个对象（详细讲解见下方）         |  C++  |
|      **delete**      |  delete（删除）释放程序动态申请的内存空间（详细讲解见下方）  |  C++  |
|    **const_cast**    |          const、volatile类型转换（详细讲解见下方）           |  C++  |
|   **dynamic_cast**   |                  动态转换（详细讲解见下方）                  |  C++  |
| **reinterpret_cast** |               非相关类型转换（详细讲解见下方）               |  C++  |
|   **static_cast**    |                相关类型转换（详细讲解见下方）                |  C++  |
|        export        | 对模板类型，在定义这些模板类对象和模板函数时，使用标准 C++ 新增加的关键字 export（导出） |  C++  |
|     **explicit**     | "禁止单参数构造函数"被用于自动型别转换，其中比较典型的例子是容器类型（详细讲解见下方） |  C++  |
|        friend        | friend（友元）声明友元关系，友元可以访问与其有 friend 关系的类中的 private/protected 成员，提高了效率 |  C++  |
|      **inline**      | inline（内联）函数的定义将在编译时在调用处展开，inline 函数一般由短小的语句组成，可以提高程序效率（详细讲解见下方） |  C++  |
|       mutable        | mutable（易变的）只能用于类的非静态和非常量数据成员。与 const 相反 |  C++  |
|      namespace       | namespace（命名空间）用于在逻辑上组织类，是一种比类大的结构  |  C++  |
|        class         | class（类）是 C++ 面向对象设计的基础，使用 class 关键字声明一个类 |  C++  |
|     **operator**     |      operator（操作符）用于操作符重载（详细讲解见下方）      |  C++  |
|     **template**     |   template（模板），C++ 中泛型机制的实现（详细讲解见下方）   |  C++  |
|     **decltype**     |               推断变量的类型（详细讲解见下方）               |  C++  |
|      **throw**       | throw（抛出）用于实现 C++ 的异常处理机制，可以"抛出"一个异常（详细讲解见下方） |  C++  |
|         try          | try（尝试）用于实现 C++ 的异常处理机制。可以在 try 中调用可能抛出异常的函数，然后在 try 后面的 catch 中捕获并进行处理 |  C++  |
|        catch         |              catch  和 try 语句一起用于异常处理              |  C++  |
|        typeid        |            指出指针或引用指向的对象的实际派生类型            |  C++  |
|        using         |                      表明使用 namespace                      |  C++  |
|     **virtual**      |  virtual（虚的），C++ 中用来实现多态机制（详细讲解见下方）   |  C++  |
|        public        | public（公有的），访问控制符，被标明为 public 的字段可以在任何类 |  C++  |
|      protected       | protected（受保护的），访问控制符，被标明为 protected 的字段只能在本类以及其继承类和友元中访问 |  C++  |
|       private        | private（私有的），访问控制符，被标明为 private 的字段只能在本类以及友元中访问 |  C++  |

## 一、auto

​	在**C语言**中使用auto关键字声明一个变量为自动变量，是C语言中应用最广泛的一种类型，在函数内定义变量时，如果没有被声明为其他类型的变量都是自动变量，也就是说，省去类型说明符auto的都是自动变量。这里的其他类型指的是变量的存储类型即：静态类型变量（static ）、寄存器类型变量（register）和外部类型变量（extern）。

​	在C语言中使用auto定义的变量可以不予初始化，但在C++中必须初始化。自动变量，在函数调用时分配存储空间，当完成调用是释放存储空间。 在C语言中，当省略数据类型，只使用auto修饰变量，在C语言中默认变量为int型。

```c++
void Test()
{
	auto int x = 10;           //定义自动变量x，auto可以省略
	int y;                     //y和z都为自动变量，如果省略了auto 关键字则隐含表示为auto类型
	double z;
}
```

​	**C++**中的auto关键字是一个类型说明符，通过变量的初始值或者表达式中参与运算的数据类型来推断变量的类型。编程时通常需要把表达式值式赋给变量，这就要求在声明变量时清楚的知道表达式的类型,C++11新标准引入了auto 类型说明符，让编译器去分析表达式的类型。由于，需要编译器推断变量或表达式的类型，所以，auto定义的变量必须初始化。例如：

```c++
auto val = 5.2f;         //编译器会根据初始化的值来推断val的数据类型为flaot，但要注意如果去掉f则编译器会认为val为double型变量
auto x = y + z;          //x初始化为y和z相加的结果，由y和z的数据类型推断x的数据类型
auto num;                //但如果在C++中出现这样的语句，会编译报错，提示“类型包含“auto符号”必须具有初始值设定项”
```

      使用auto也能在一条语句中声明多个变量。因为一条语句声明时只能有一种基本数据类型，所以该语句中的所有变量初始基本数据类型必须一样，例如：

```c++
auto i = 0, *p = &i;        //正确：i是整数、p是整形指针
auto sz = 0, pi = 3, 14;    //错误：sz和pi的类型不一致
```

      auto和 decltype 的作用有点相似，都可以推断某个表达式的具体类型，当我们希望从表达式的值推断出要定义的变量的类型，但不想用该表达式的值初始化变量时，可以使用 decltype ，作用是选择并返回操作数的数据类型，但并不计算表达式的值。如果 decltype 使用的表达式不是一个变量，则 decltype 返回表达式结果对用的类型，”如果我们仅仅是想根据初始值确定一个变量合适的数据类型，那么auto是最佳人选。而只有当我们需要推断某个表达式的数据类型，并将其作为一种新的数据类型重复使用（比如，定义多个相同类型变量）或者单独使用（比如，作为函数的返回值类型）时，我们才真正需要用到 decltype “。

      在范围for语句中，经常会使用到auto关键字，正如文章开篇举得那个例子，范围for语句遍历给定序列中的每个元素并对序列中的每个值执行某种操作。其语法形式为：

```c++
/*
	*declaration 部分定义一个变量，该变量用于访问序列中的基础元素，expression部分是一个对象，用于表示
	*一个序列。每次迭代，declaration部分的变量会初始化为expression部分的下一个元素值，statment是对字
	*符的操作语句
*/

for (declaration : expression)
{
	statement
}
```
       下面看一个例子，将上面介绍到的关键字和范围for语句梳理一下：



```c++
//编写一段程序，使用范围for语句将字符串内的所有字符用‘X’代替
#include <iostream>
#include <string>
using namespace std;
int main()
{
	string str;
	getline(cin, str);     //从输入中读取一行赋值给str1
	//auto 是一个类型说明符，通过变量的初始值来判断变量的类型 
	for (auto &c : str)                //对于字符串str中的每一个c
	{
		//decltype 类型指示符，选择并返回操作数的数据类型，如果decltype使用
    	//的表达式不是一个变量，则decltype返回表达式结果对应的类型
		for (decltype(str.size()) index = 0; index < str.size(); ++index)
		{
			str[index] = 'X';
		}
	}
	cout << str << endl;               //打印替换后的字符串
	system("pause");
	return 0;
}
```
​	简单分析：上面的代码完成的功能是，把字符串中的所有字符‘X’用代替。先从键盘读取一行字符串，然后使用范围for语句对其进行处理，在范围for语句中使用auto关键字推断变量c的数据类型，因为要改变字符串中的字符，所以将循环变量C定义为引用类型，然后使用for循环依次处理字符串str中的字符，将其修改为字符‘X’，在使用下标处理字符串中的字符是，我们需要知道字符串的长度，c++中的size（）函数用于返回字符串的长度,即：字符串中字符的个数，类似于C语言中的strlen，字符串的下标从0开始，所以下标的取值大于等于0并且小于字符串的size()值，循环控制条件为：

​	

```c++
index < str.size(); 
```

​	所以index为decltype(str.size())型的变量，这里使用decltype返回函数size()返回值类型，并且将其作为数据类型定义index作为字符串中字符的下标，（实际上size()返回的是一个size_t类型的值，个人认为，可以把 size_t 理解为unsigned int型），然后，在循环体内实现字符的替换，上面的代码中用到了本文中讲到的auto类型说明符，decltype类型指示符以及范围for语句，可以帮助我们简单的理解其简单应用。

##  二、struct

​	在C语言中，struct定义一个结构体，属于自定义类型，可包含不同类型的变量数据，同时采用内存对齐的方式。

```c
struct Student{
    char*name;//姓名
    int age;//年龄
    float height;//身高
};
struct Student stu;
```

注意：

1. 不允许对结构体本身递归定义
2. 结构体内可以包含别的结构体
3. 定义结构体类型，只是说明了该类型的组成情况，并没有给它分配存储空间，就像系统不为int类型本身分配空间一样。只有当定义属于结构体类型的变量时，系统才会分配存储空间给该变量 
4. 结构体变量占用的内存空间是其成员所占内存之和，而且各成员在内存中按定义的顺序依次排列 

> 问题：结合数据在内存的存储方式，当我们在栈上申请一块儿空间，作为数组或内置类型变量的存储空间，如何申请和开辟，按位怎么存放？堆上申请空间存放结构体变量呢？

​	*首先，我们在栈上申请一块儿空间，栈的地址由低到高，每个字节8位，当我们存放int或者char类型的变量时，按字节对齐，小端模式下，int是32位，低地址存放数据的低位，高地址存放数据的高位，char是一个字节8位，直接存放，而数组是一个连续空间，先看数组元素类型，再存储。*

​	*在堆上开辟空间，无论是new还是malloc，底层都有malloc的实现，我们知道Windows下[malloc底层]()是通过break指针实现内存的开辟，也就是说，内存已经被开好了，我们只需要去申请空间，而堆的地址由高地址到低地址，结构体到的存储按照内存对齐排列，所以按照结构体数据的顺序，高地址存放越前的数据，数据内部的存储按照大小端对齐，若结构体中有数组，数组的存储任然是低地址到高地址。*

## 三、static



