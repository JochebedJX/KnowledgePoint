# C语言和C++关键字总结

------

   * [C语言和C  关键字总结](#c语言和c关键字总结)
      * [一、auto](#一auto)
            * [1、C语言](#1c语言)
            * [2、C  ](#2c)
      * [二、struct](#二struct)
      * [三、static](#三static)
            * [1、程序的内存分配](#1程序的内存分配)
            * [2、局部静态变量](#2局部静态变量)
            * [3、全局静态变量](#3全局静态变量)
            * [4、静态函数](#4静态函数)
            * [5、类的静态成员变量](#5类的静态成员变量)
            * [6、类的静态成员函数](#6类的静态成员函数)
            * [7、static const 成员](#7static-const-成员)
      * [四、register](#四register)
            * [1、皇帝身边的小太监----寄存器](#1皇帝身边的小太监----寄存器)
            * [2、register修饰符暗示编译程序相应的变量将被频繁地使用](#2register修饰符暗示编译程序相应的变量将被频繁地使用)
            * [3、但是使用register修饰符有几点限制](#3但是使用register修饰符有几点限制)
      * [五、const](#五const)
      * [六、volatile](#六volatile)
      * [七、extern](#七extern)
      * [八、sizeof](#八sizeof)
      * [九、new](#九new)
      * [十、delete](#十delete)
      * [十一、const_cast](#十一const_cast)
      * [十二、dynamic_cast](#十二dynamic_cast)
      * [十三、reinterpret_cast](#十三reinterpret_cast)
      * [十四、static_cast](#十四static_cast)
      * [十五、explicit](#十五explicit)
      * [十六、inline](#十六inline)
      * [十七、operator](#十七operator)
      * [十八、template](#十八template)
      * [十九、decltype](#十九decltype)
      * [二十、throw、try、catch](#二十throwtrycatch)
      * [二十一、virtual](#二十一virtual)

|        关键字        |                             意义                             | C/C++ |
| :------------------: | :----------------------------------------------------------: | :---: |
|       **auto**       |  声明自动变量，缺省时编译器一般默认为auto（详细讲解见下方）  | C/C++ |
|         int          |                         声明整型变量                         | C/C++ |
|        double        |                        声明双精度变量                        | C/C++ |
|         long         |                        声明长整型变量                        | C/C++ |
|         char         |                        声明字符型变量                        | C/C++ |
|        float         |                        声明浮点型变量                        | C/C++ |
|        short         |                        声明短整型变量                        | C/C++ |
|        signed        |                      声明有符号类型变量                      | C/C++ |
|       unsigned       |                      声明无符号类型变量                      | C/C++ |
|      **struct**      |               声明结构体变量（详细讲解见下方）               | C/C++ |
|        union         |                       声明联合数据类型                       | C/C++ |
|         enum         |                         声明枚举类型                         | C/C++ |
|      **static**      |                声明静态变量（详细讲解见下方）                | C/C++ |
|        switch        |                         用于开关语句                         | C/C++ |
|         case         |                         开关语句分支                         | C/C++ |
|       default        |                    开关语句中的“其他”分支                    | C/C++ |
|        break         |                         跳出当前循环                         | C/C++ |
|     **register**     |               声明寄存器变量（详细讲解见下方）               | C/C++ |
|      **const**       |                声明只读变量（详细讲解见下方）                | C/C++ |
|     **volatile**     |     说明变量在程序执行中可被隐含地改变（详细讲解见下方）     | C/C++ |
|       typedef        |            用以给数据类型取别名(当然还有其他作用)            | C/C++ |
|      **extern**      | 声明变量是在其他文件正声明(也可以看做是引用变量)（详细讲解见下方） | C/C++ |
|        return        |           子程序返回语句(可以带参数，也可不带参数)           | C/C++ |
|         void         |           声明函数无返回值或无参数，声明空类型指针           | C/C++ |
|       continue       |                 结束当前循环，开始下一轮循环                 | C/C++ |
|          do          |                       循环语句的循环体                       | C/C++ |
|        while         |                      循环语句的循环条件                      | C/C++ |
|          if          |                           条件语句                           | C/C++ |
|         else         |                 条件语句否定分支(与if 连用)                  | C/C++ |
|         for          |                 一种循环语句(可意会不可言传)                 | C/C++ |
|         goto         |                        无条件跳转语句                        | C/C++ |
|      **sizeof**      |          计算对象所占内存空间大小（详细讲解见下方）          | C/C++ |
|         asm          |       asm (指令字符串)：允许在 C++ 程序中嵌入汇编代码        |  C++  |
|         bool         | C++ 中的基本数据结构，其值可选为 true（真）或者 false（假）  |  C++  |
|       **new**        |        new（新建）用于新建一个对象（详细讲解见下方）         |  C++  |
|      **delete**      |  delete（删除）释放程序动态申请的内存空间（详细讲解见下方）  |  C++  |
|    **const_cast**    |          const、volatile类型转换（详细讲解见下方）           |  C++  |
|   **dynamic_cast**   |                  动态转换（详细讲解见下方）                  |  C++  |
| **reinterpret_cast** |               非相关类型转换（详细讲解见下方）               |  C++  |
|   **static_cast**    |                相关类型转换（详细讲解见下方）                |  C++  |
|        export        | 对模板类型，在定义这些模板类对象和模板函数时，使用标准 C++ 新增加的关键字 export（导出） |  C++  |
|     **explicit**     | "禁止单参数构造函数"被用于自动型别转换，其中比较典型的例子是容器类型（详细讲解见下方） |  C++  |
|        friend        | friend（友元）声明友元关系，友元可以访问与其有 friend 关系的类中的 private/protected 成员，提高了效率 |  C++  |
|      **inline**      | inline（内联）函数的定义将在编译时在调用处展开，inline 函数一般由短小的语句组成，可以提高程序效率（详细讲解见下方） |  C++  |
|       mutable        | mutable（易变的）只能用于类的非静态和非常量数据成员。与 const 相反 |  C++  |
|      namespace       | namespace（命名空间）用于在逻辑上组织类，是一种比类大的结构  |  C++  |
|        class         | class（类）是 C++ 面向对象设计的基础，使用 class 关键字声明一个类 |  C++  |
|     **operator**     |      operator（操作符）用于操作符重载（详细讲解见下方）      |  C++  |
|     **template**     |   template（模板），C++ 中泛型机制的实现（详细讲解见下方）   |  C++  |
|     **decltype**     |               推断变量的类型（详细讲解见下方）               |  C++  |
|      **throw**       | throw（抛出）用于实现 C++ 的异常处理机制，可以"抛出"一个异常（详细讲解见下方） |  C++  |
|         try          | try（尝试）用于实现 C++ 的异常处理机制。可以在 try 中调用可能抛出异常的函数，然后在 try 后面的 catch 中捕获并进行处理 |  C++  |
|        catch         |              catch  和 try 语句一起用于异常处理              |  C++  |
|        typeid        |            指出指针或引用指向的对象的实际派生类型            |  C++  |
|        using         |                      表明使用 namespace                      |  C++  |
|     **virtual**      |  virtual（虚的），C++ 中用来实现多态机制（详细讲解见下方）   |  C++  |
|        public        | public（公有的），访问控制符，被标明为 public 的字段可以在任何类 |  C++  |
|      protected       | protected（受保护的），访问控制符，被标明为 protected 的字段只能在本类以及其继承类和友元中访问 |  C++  |
|       private        | private（私有的），访问控制符，被标明为 private 的字段只能在本类以及友元中访问 |  C++  |

## 一、auto

#### 1、C语言	

​	在**C语言**中使用auto关键字声明一个变量为自动变量，是C语言中应用最广泛的一种类型，在函数内定义变量时，如果没有被声明为其他类型的变量都是自动变量，也就是说，省去类型说明符auto的都是自动变量。这里的其他类型指的是变量的存储类型即：静态类型变量（static ）、寄存器类型变量（register）和外部类型变量（extern）。

​	在C语言中使用auto定义的变量可以不予初始化，但在C++中必须初始化。自动变量，在函数调用时分配存储空间，当完成调用是释放存储空间。 在C语言中，当省略数据类型，只使用auto修饰变量，在C语言中默认变量为int型。

```c++
void Test()
{
	auto int x = 10;           //定义自动变量x，auto可以省略
	int y;                     //y和z都为自动变量，如果省略了auto 关键字则隐含表示为auto类型
	double z;
}
```

#### 2、C++	

​	**C++**中的auto关键字是一个类型说明符，通过变量的初始值或者表达式中参与运算的数据类型来推断变量的类型。编程时通常需要把表达式值式赋给变量，这就要求在声明变量时清楚的知道表达式的类型,C++11新标准引入了auto 类型说明符，让编译器去分析表达式的类型。由于，需要编译器推断变量或表达式的类型，所以，auto定义的变量必须初始化。例如：

```c++
auto val = 5.2f;         //编译器会根据初始化的值来推断val的数据类型为flaot，但要注意如果去掉f则编译器会认为val为double型变量
auto x = y + z;          //x初始化为y和z相加的结果，由y和z的数据类型推断x的数据类型
auto num;                //但如果在C++中出现这样的语句，会编译报错，提示“类型包含“auto符号”必须具有初始值设定项”
```

      使用auto也能在一条语句中声明多个变量。因为一条语句声明时只能有一种基本数据类型，所以该语句中的所有变量初始基本数据类型必须一样，例如：

```c++
auto i = 0, *p = &i;        //正确：i是整数、p是整形指针
auto sz = 0, pi = 3, 14;    //错误：sz和pi的类型不一致
```

      auto和 decltype 的作用有点相似，都可以推断某个表达式的具体类型，当我们希望从表达式的值推断出要定义的变量的类型，但不想用该表达式的值初始化变量时，可以使用 decltype ，作用是选择并返回操作数的数据类型，但并不计算表达式的值。如果 decltype 使用的表达式不是一个变量，则 decltype 返回表达式结果对用的类型，”如果我们仅仅是想根据初始值确定一个变量合适的数据类型，那么auto是最佳人选。而只有当我们需要推断某个表达式的数据类型，并将其作为一种新的数据类型重复使用（比如，定义多个相同类型变量）或者单独使用（比如，作为函数的返回值类型）时，我们才真正需要用到 decltype “。

      在范围for语句中，经常会使用到auto关键字，正如文章开篇举得那个例子，范围for语句遍历给定序列中的每个元素并对序列中的每个值执行某种操作。其语法形式为：

```c++
/*
	*declaration 部分定义一个变量，该变量用于访问序列中的基础元素，expression部分是一个对象，用于表示
	*一个序列。每次迭代，declaration部分的变量会初始化为expression部分的下一个元素值，statment是对字
	*符的操作语句
*/

for (declaration : expression)
{
	statement
}
```
       下面看一个例子，将上面介绍到的关键字和范围for语句梳理一下：

```c++
//编写一段程序，使用范围for语句将字符串内的所有字符用‘X’代替
#include <iostream>
#include <string>
using namespace std;
int main()
{
	string str;
	getline(cin, str);     //从输入中读取一行赋值给str1
	//auto 是一个类型说明符，通过变量的初始值来判断变量的类型 
	for (auto &c : str)                //对于字符串str中的每一个c
	{
		//decltype 类型指示符，选择并返回操作数的数据类型，如果decltype使用
    	//的表达式不是一个变量，则decltype返回表达式结果对应的类型
		for (decltype(str.size()) index = 0; index < str.size(); ++index)
		{
			str[index] = 'X';
		}
	}
	cout << str << endl;               //打印替换后的字符串
	system("pause");
	return 0;
}
```
​	简单分析：上面的代码完成的功能是，把字符串中的所有字符‘X’用代替。先从键盘读取一行字符串，然后使用范围for语句对其进行处理，在范围for语句中使用auto关键字推断变量c的数据类型，因为要改变字符串中的字符，所以将循环变量C定义为引用类型，然后使用for循环依次处理字符串str中的字符，将其修改为字符‘X’，在使用下标处理字符串中的字符是，我们需要知道字符串的长度，c++中的size（）函数用于返回字符串的长度,即：字符串中字符的个数，类似于C语言中的strlen，字符串的下标从0开始，所以下标的取值大于等于0并且小于字符串的size()值，循环控制条件为：​

```c++
index < str.size(); 
```

​	所以index为decltype(str.size())型的变量，这里使用decltype返回函数size()返回值类型，并且将其作为数据类型定义index作为字符串中字符的下标，（实际上size()返回的是一个size_t类型的值，个人认为，可以把 size_t 理解为unsigned int型），然后，在循环体内实现字符的替换，上面的代码中用到了本文中讲到的auto类型说明符，decltype类型指示符以及范围for语句，可以帮助我们简单的理解其简单应用。

##  二、struct

​	在C语言中，struct定义一个结构体，属于自定义类型，可包含不同类型的变量数据，同时采用内存对齐的方式。

```c
struct Student{
    char*name;//姓名
    int age;//年龄
    float height;//身高
};
struct Student stu;
```

注意：

1. 不允许对结构体本身递归定义
2. 结构体内可以包含别的结构体
3. 定义结构体类型，只是说明了该类型的组成情况，并没有给它分配存储空间，就像系统不为int类型本身分配空间一样。只有当定义属于结构体类型的变量时，系统才会分配存储空间给该变量 
4. 结构体变量占用的内存空间是其成员所占内存之和，而且各成员在内存中按定义的顺序依次排列 

> 问题：结合数据在内存的存储方式，当我们在栈上申请一块儿空间，作为数组或内置类型变量的存储空间，如何申请和开辟，按位怎么存放？堆上申请空间存放结构体变量呢？

​	*首先，我们在栈上申请一块儿空间，栈的地址由低到高，每个字节8位，当我们存放int或者char类型的变量时，按字节对齐，小端模式下，int是32位，低地址存放数据的低位，高地址存放数据的高位，char是一个字节8位，直接存放，而数组是一个连续空间，先看数组元素类型，再存储。*

​	*在堆上开辟空间，无论是new还是malloc，底层都有malloc的实现，我们知道Windows下[malloc底层]()是通过break指针实现内存的开辟，也就是说，内存已经被开好了，我们只需要去申请空间，而堆的地址由高地址到低地址，结构体到的存储按照内存对齐排列，所以按照结构体数据的顺序，高地址存放越前的数据，数据内部的存储按照大小端对齐，若结构体中有数组，数组的存储任然是低地址到高地址。*

## 三、static

#### 1、程序的内存分配

1. **静态存储区**，全局变量和静态变量的存储是在静态区，初始化的全局变量和静态变量在一块区域 .data，未初始化的全局变量和静态变量在相邻的另一块区域 .bss。程序结束后由系统释放。（相当于未初始化数据区和已初始化数据区）
2. **栈区**，由编译器自动分配释放，存放函数的参数值、局部变量等。
3. **堆区**，一般由程序员分配释放，即动态内存分配。
4. **文字常量区**，存放常量字符串，程序结束后由系统释放。
5. **程序代码区**，用于存放程序的二进制代码。

#### 2、局部静态变量

​	在局部变量之前加上关键字 static，局部变量就变成一个局部静态变量。若不加static修饰，函数或者代码块中的变量在函数或者代码块执行完毕后就直接回收销毁了，每次执行都会重新分配内存，每次都会销毁；当static 作用于代码块内部的变量声明时，static关键字用于修改变量的存储类型。从自动变量变为静态变量，变量的属性和作用域不受影响。

**在内存中的位置**：静态存储区。

**作用域**：仍为局部作用域，当其所在的函数或者语句块结束的时候，作用域结束。然而**局部静态变量**离开作用域后，并没有被销毁，仍然驻留在内存中，只有该函数可以对其进行调用或者访问。也就是说，加 static 修饰，函数或者代码块中的变量在函数或者代码块执行第一次初始化分配内存后，就算函数或者代码块执行完毕，该变量也不会被回收销毁，直到程序结束 static 变量才会被回收。

#### 3、全局静态变量

​	在全局变量前加上关键字 static，全局变量就变成了一个全局静态变量。

**在内存中的位置**：静态存储区。

**初始化**：未经初始化的全局静态变量被自动初始化为**0**。

**作用域**：全局静态变量在其所声明的文件之外是不可见的，准确的说是从定义处到文件末尾。

**链接属性**：当 static 作用于函数定义时，或者用于代码块之外的变量声明时，static关键字用于修改标识符的链接属性。**外部链接属性变为内部链接属性**，标识符的存储类型和作用域不受影响。也就是说变量或者函数只能在当前源文件中访问，不能在其他源文件中访问。

#### 4、静态函数

​	在函数返回类型前加关键字 static，函数就被定义为静态函数，静态函数只在其所声明的文件中可见，不可被其他文件所使用。

**链接属性**：当 static 作用于函数定义时，或者用于代码块之外的变量声明时，static关键字用于修改标识符的链接属性。外部链接属性变为内部链接属性，标识符的存储类型和作用域不受影响。也就是说变量或者函数只能在当前源文件中访问，不能在其他源文件中访问。

#### 5、类的静态成员变量

​	C++中，**静态成员属于整个类而不是某个对象**，静态成员变量只存储一份为所有类对象所公共。相比于全局变量，类的静态成员变量实现了多个对象之间的数据共享而不破坏隐藏的原则。类的静态成员，属于类，也属于对象，但终归属于类。

​	**类的静态成员变量必须在类内定义，类外初始化。**

#### 6、类的静态成员函数

​	类的静态函数，不能访问类的私有成员，**只能访问类的静态成员**，用于管理静态成员。静态成员函数属于类，也属于对象，但终归属于类。

​	静态成员函数的意义，不在于信息共享和数据沟通，而在于**管理静态数据成员**，完成对静态数据成员的封装。

#### 7、static const 成员

​	一个类的成员，**既要实现共享，又要实现不可改变**，则使用 static const 修饰，需要**类内就地初始化**。

> 问题：普通全局变量与 static 全局变量的区别？static 局部变量与普通局部变量的区别？static 函数与普通函数的区别？

1. 两者都是静态存储方式，区别在于普通全局变量的作用域是整个原程序，静态全局变量的作用域是定义该变量的源文件。将全局变量改为静态全局变量，改变了其作用域，限制了其使用范围。
2. 普通局部变量存储于栈空间，而静态局部变量=则存储于静态存储区。将局部变量改为静态局部变量后，改变了其存储方式，即改变了其生存期。
3. 与普通函数作用域不同，静态函数仅在本文件。只在当前源文件中使用的函数应当被声明为内部函数 static，在当前源文件中声明和定义。对于可在当前源文件之外使用的函数，应当在一个头文件中声明，要使用这些函数的源文件包含该头文件即可。

> 特点: static局部变量的”记忆性”与生存期的”全局性” 

​	所谓”记忆性”是指在两次函数调用时, 在第二次调用进入时, 能保持第一次调用退出时的值。
	注意事项: 

1. “记忆性”, 程序运行很重要的一点就是可重复性, 而static变量的”记忆性”破坏了这种可重复性, 造成不同时刻至运行的结果可能不同. 
2. “生存期”全局性和唯一性. 普通的局部变量的存储空间分配在stack上, 因此每次调用函数时, 分配的空间都可能不一样, 而static具有全局唯一性的特点, 每次调用时, 都指向同一块内存, 这就造成一个很重要的问题——**不可重入性**

## 四、register

​	register：这个关键字请求编译器尽可能的将变量存在CPU内部寄存器中，而不是通过内存寻址访问，以提高效率。**注意是尽可能，不是绝对**。

​	因为，如果定义了很多register变量，可能会超过CPU的寄存器个数，超过容量。所以只是可能。

#### 1、皇帝身边的小太监----寄存器

​	不知道什么是寄存器？那见过太监没有？没有？其实我也没有。没见过不要紧，见过就麻烦大了。^_^，大家都看过古装戏，那些皇帝们要阅读奏章的时候，大臣总是先将奏章交给皇帝旁边的小太监，小太监呢再交给皇帝同志处理。这个小太监只是个中转站，并无别的功能。
	那我们再联想到我们的CPU。CPU 就是我们的皇帝同志，大臣就相当于我们的内存，数据从他这拿出来。那小太监就是我们的寄存器了（这里先不考虑CPU 的高速缓存区）。数据从内存里拿出来先放到寄存器，然后CPU 再从寄存器里读取数据来处理，处理完后同样把数据通过寄存器存放到内存里，CPU 不直接和内存打交道。这里要说明的一点是：小太监是主动的从大臣手里接过奏章，然后主动的交给皇帝同志，**但寄存器没这么自觉，它从不主动干什么事**。一个皇帝可能有好些小太监，那么一个CPU 也可以有很多寄存器，不同型号的CPU 拥有寄存器的数量不一样。
	为啥要这么麻烦啊？**就是因为速度**。寄存器其实就是一块一块小的存储空间，只不过**其存取速度要比内存快得多**。进水楼台先得月，它离CPU 很近，CPU 一伸手就拿到数据了，比在那么大的一块内存里去寻找某个地址上的数据是不是快多了？那有人问既然它速度那么快，那我们的内存硬盘都改成寄存器得了呗。我要说的是：你真有钱！

#### 2、register修饰符暗示编译程序相应的变量将被频繁地使用 

​	如果可能的话，应将变量保存在CPU的寄存器中，以加快其存储速度。

#### 3、但是使用register修饰符有几点限制

1. **register变量必须是能被CPU所接受的类型。**

   这通常意味着register变量必须是一个单个的值，并且长度应该**小于或者等于整型的长度**。不过，有些机器的寄存器也能存放浮点数。

2. **因为register变量可能不存放在内存中，所以不能用“&”来获取register变量的地址。**“&”是用于内存地址的获取。

3. **只有局部自动变量和形式参数可以作为寄存器变量，其它（如全局变量）不行。**

   在调用一个函数时占用一些寄存器以存放寄存器变量的值，函数调用结束后释放寄存器。此后，在调用另外一个函数时又可以利用这些寄存器来存放该函数的寄存器变量。

4. **局部静态变量不能定义为寄存器变量。**不能写成：register static int a, b, c;

5. **由于寄存器的数量有限（不同的cpu寄存器数目不一），不能定义任意多个寄存器变量**，而且某些寄存器只能接受特定类型的数据（如指针和浮点数），因此真正起作用的register修饰符的数目和类型都依赖于运行程序的机器，而任何多余的register修饰符都将被编译程序所忽略。

> 注意
>

​	早期的C编译程序不会把变量保存在寄存器中，除非你命令它这样做，这时register修饰符是C语言的一种很有价值的补充。register关键字请求让编译器将变量a直接放入寄存器里面，以提高读取速度，在C语言中register关键字修饰的变量不可以被取地址，但是c++中进行了优化。然而，随着编译程序设计技术的进步，在决定哪些变量应该被存到寄存器中时，现在的C编译环境能比程序员做出更好的决定。实际上，许多编译程序都会忽略register修饰符，因为尽管它完全合法，但它仅仅是暗示而不是命令。在早期c语言编译器不会对代码进行优化，因此使用register关键字修饰变量是很好的补充，大大提高的速度。

​	c++中依然支持register关键字，但是c++编译器也有自己的优化方式，即某些变量不用register关键字进行修饰，编译器也会将多次连续使用的变量优化放入寄存器中，例如入for循环的循环变量i（频繁使用）。

​	c++中也可以对register修饰的变量取地址，不过c++编译器发现程序中需要取register关键字修饰的变量的地址时，register关键字的声明将变得无效。

## 五、const

## 六、volatile

## 七、extern

## 八、sizeof

## 九、new

## 十、delete

## 十一、const_cast

## 十二、dynamic_cast

## 十三、reinterpret_cast

## 十四、static_cast

## 十五、explicit

## 十六、inline

## 十七、operator

## 十八、template

## 十九、decltype

## 二十、throw、try、catch

## 二十一、virtual



