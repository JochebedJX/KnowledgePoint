# Windows下：

------

   * [Windows下：](#windows下)
      * [一、栈区（stack）](#一栈区stack)
      * [二、堆区（heap）](#二堆区heap)
      * [三、全局区（静态区）（static）](#三全局区静态区static)
      * [四、文字常量区](#四文字常量区)
      * [五、程序代码区](#五程序代码区)
      * [小结](#小结)
   * [Linux下：](#linux下)
      * [Linux内存管理](#linux内存管理)

一个由C/C++编译的程序占用的内存分为以下几个部分：

## 一、栈区（stack）

​	由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。

​	**申请方式 **: 由系统自动分配。 例如，声明在函数中一个局部变量 `int b`; 系统自动在栈中为b 开辟空间 

​	**申请后系统的响应**：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 

​	**申请大小的限制**：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow（栈溢出）。因此，能从栈获得的空间较小。 

​	**申请效率的比较**：栈由系统自动分配，速度较快。但程序员是无法控制的。 

​	**堆和栈中的存储内容**： 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。 当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。

> 静态内存：静态的内存使用的是栈空间内存，不用程序员自己来分配。因为静态变量占用的存储空间对于编译器而言是可预计的，静态内存只需要编程的时候直接声明就可以了。 静态内存分配好后，程序运行过程中一直存在不会被释放，且一旦分配好，其内存大小就固定下来不能改变，在编译和链接的阶段就会分配好。

## 二、堆区（heap）

​	一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。

​	**申请方式**：需要程序员自己申请，并指明大小，在c中malloc函数，如`p1 = (char *)malloc(10);` 在C++中用new运算符，如`p2 =new  string();` 但是注意p1、p2本身是在栈中的。

​	**申请后系统的响应**：首先应该知道操作系统有一个记录**空闲内存地址的链表**，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的**释放本内存空间**。另外，由于找到的堆结点的大小不一定正好等于申请的大小， 系统会自动的将多余的那部分重新放入空闲链表中。(malloc 底层原理)

​	**申请大小的限制**：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 

​	**申请效率的比较：**堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便. 另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不 是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度 快，也最灵活

​	**堆和栈中的存储内容**：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。

​	**存取效率的比较**： 

```c++
char s1[] = "aaa"; 
char *s2 = "bbb"; 
```

​	aaa是在运行时刻赋值的； 而bbb是在编译时就确定的； 但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。

> 动态内存：动态内存需要由程序员根据需要来自己分配并收回，动态内存是因为要执行一些因为外部请求而浮动占用内存的应用，所以动态的内存分配时候会用new关键字或malloc或calloc函数，之所以要程序员自己来分配内存是由于有时候不能确定程序要使用多少内存。 动态内存是程序运行过程中，根据程序的需要分配和释放，其大小可变。

## 三、全局区（静态区）（static）

​	全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放 

## 四、文字常量区

常量字符串就是放在这里的。 程序结束后由系统释放 

## 五、程序代码区

存放函数体的二进制代码。 

## 小结

​	堆和栈的区别可以用如下的比喻来看出： 使用**栈**就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是**快捷**，**但是自由度小**。 使用**堆**就像是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且**自由度大**。

​	堆和栈的区别主要分： 操作系统方面的堆和栈，如上面说的那些，不多说了。 还有就是数据结构方面的堆和栈，这些都是不同的概念。这里的堆实际上指的就是（满足堆性质的）优先队列的一种数据结构，第1个元素有最高的优先权；栈实际上就是满足先进后出的性质的数学或数据结构。 

------



# Linux下：

## Linux内存管理

​	我们先来看下linux内存布局，此图比我之前写的那篇文章写的布局更详细

![img](E:/%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0/qq0871A93E81DECD4CB2EB6705B7335D2C/152bf51016c54d9fb3ab8fa022ce9c03/.webp)

​	在linux中，每一个进程都被抽象为task_struct结构体，称为**进程描述符**，存储着进程各方面的信息；例如打开的文件，信号以及内存等等；然后task_struct中的一个属性**mm_struct**管理着进程的所有虚拟内存，称为**内存描述符**。在mm_struct结构体中，存储着进程各个内存段的开始以及结尾，如上图所示；这进程使用的物理内存，即常驻内存RSS页数，这个内存使用的虚拟地址空间VSZ页数，还有这个进程虚拟内存区域集合和页表。

​	从上面这个图可以看出，进程是由**代码段**Text segment,**数据段**（已初始化的全局，静态变量），**BSS段**（未初始化的全局，静态变量），**堆**，**内存映射区**以及**栈**；

​	每一块虚拟内存区(VMA)都是由一块连续的虚拟地址组成，这些地址从不覆盖。一个vm_area_struct实例描述了一块内存区域，包括这块内存区域的开始以及结尾地址；flags标志决定了这块内存的访问权限和行为；vm_file决定这块内存是由哪个文件映射的，如果没有文件映射，则这块内存为匿名的(anonymous)。上述图中提到的每个内存段，都对应于一个vm_area_struct结构。如下图所示

![img](E:/%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0/qq0871A93E81DECD4CB2EB6705B7335D2C/13030ec2a6f4472db3fbda143e891ea1/.webp)

​	上图即为**/bin/gonzo进程的内存布局**。程序的二进制文件映射到代码段和数据段，**代码段为只读只执行**，不可更改；**全局以及静态的未初始化的变量映射到BSS段，为匿名映射**，**堆和栈也是匿名映射**，因为没有相应的文件映射；内存映射区可以映射共享库，映射文件以及匿名映射，所以这块内存段可以是文件映射也可以是匿名映射。而且不同的文件，映射到不同的vm_area_struct区。

这些vm_area_struct集合存储在mm_struct中的**一个单向链表和红黑树**中；当输出**/proc/pid/maps**文件时，只需要遍历这个**链表**即可。**红黑树主要是为了快速定位到某一个内存块,红黑树的根存储在mm_rb域**。

之前介绍过，线性地址需要通过页表才能转换为物理地址。每个进程的内存描述符也保存了**这个进程页表指针pgd**，每一块虚拟内存页都和页表的某一项对应。

虚拟内存是不存储任何数据的，**它只是将地址空间映射到物理内存**。物理内存有内核**伙伴系统**分配，如果一块物理内存没有被映射，就可以被伙伴系统分配给虚拟内存。刚分配的物理内存叶框可能是匿名的，存储进程数据，也可能是也缓存，存储文件或块设备的数据。一块虚拟内存vm_area_struct块是由连续的虚拟内存页组成的，而这些虚拟内存块映射的物理内存却不一定连续，如下图所示:

![img](E:/%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0/qq0871A93E81DECD4CB2EB6705B7335D2C/c9cc01bfa4ce4431b8f4312c92d83e03/.webp)

​	如上图所示，有三个页映射到物理内存，还有两个页没有映射，所以常驻内存RSS为12kb，而虚拟内存大小为20kb。对于有映射到物理内存的三个页的页表项PTE的Present标志设为1，而**两个没有映射物理内存的虚拟内存页表项的Present位清除。所以这时访问那两块内存，则会导致异常缺页**。

​	VMA就像应用程序和内核的一个**契约**。当应用程序申请内存或者文件映射时，内核先响应这个请求，分配或更新虚拟内存；但是这些虚拟内存并没有映射到真实的物理内存。而是等到**内存访问产生一个内存异常缺页时才真正映射物理内存**。即当访问没有映射的虚拟内存时，由于页表项的Present位没有被设置，所以此时会产生一个缺页异常。VMA记录和页表项两个在解决内存缺页，释放内存以及内存swap out都起着重要的作用。下面图展示了上述情况：

![img](E:/%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0/qq0871A93E81DECD4CB2EB6705B7335D2C/636d4eaec01547cca570cd246baaaa61/.webp)

1. 一开始堆中只有8kb的内存，而且都已经映射到物理内存；
2. 当调用**brk()**函数扩展堆时，**新的页是没有映射到物理内存的**；
3. 当处理器需要访问一个地址，而且这个地址在上述刚分配的虚拟内存中，这时产生一个缺页异常；
4. 这时进程向伙伴系统申请一页的物理内存，映射到那块虚拟内存上，并添加页表项，设置Present位。

自此，这个内存管理暂时就说到这。总结下：

1. linux进程的内存布局的每个段都是有一个vm_area_struct,而这个实例是由连续的虚拟内存地址组成；
2. 当请求内存时，先是扩展vm_area_struct或者新分配一个vm_area_struct，但是并不映射物理内存，只有等到访问这块内存时，产生缺页异常，内核才分配物理内存。
3. 参考我的博客：[内存映射文件原理](https://blog.csdn.net/Jochebed666/article/details/89220454)

