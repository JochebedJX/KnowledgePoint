# malloc的底层实现

------

> 1、内核和用户进程分配内存的特点和原因
>
> 答：1）内核中只要请求内存得以满足，都会返回页描述符的地址或线性地址
>
> ​       2）当用户态进程申请动态内存时，并没有获取请求的页框，而是获得一个线性区，当第一次访问分配的线性区的时候，发生缺页中断，检查线性区是否是合法的，如果是合法的，查找或分配物理内存，并且填充该物理内存，最后建立虚拟地址和物理地址的映射
>
> ​	原因：进程对动态内存的请求认为是不紧迫的，内核总是推迟给用户态进程分配动态内存
>
> ​	由于用户态进程是不可信任的，内核必须随时准能被捕获用户态进程引起的寻址错误
>
> 2、malloc的工作原理
>
> 答：malloc函数分配内存主要是使用brk和mmap系统调用；
>
> ​       brk是_edata指针堆中的地址往高地址推，mmap是在堆和栈之间找分配一块空闲的虚拟内存；
>
> ​       当使用malloc分配的字节数小于128k的时候，调用brk分配虚拟内存；
>
> ​       当malloc分配的字节数大于128的时候，使用过mmap分配虚拟内存；
>
> ​       brk和mmap分配的都是虚拟内存，并没有分配物理内存，当第一次访问已经分配的虚拟内存的时候，发生缺页中断，操作系统负责分配物理内存，并且建立虚拟内存和物理内存之间的映射关系。
>
> ​    
>
> 3、free的工作原理
>
> 答：举例，假射系统调用brk先分配了内存A，然后在分配内存B，系统调用mmap分配了内存C，
>
> ​       如果free由mmap分配的内存C，直接将C中的虚拟内存和物理内存释放回给操作系统
>
> ​       如果free有brk分配的A，A的虚拟内存和物理内存都没有释放，但是A的内存可以重用
>
> ​       如果再释放brk分配的B，如果A和B的内存数目大于128k则将A和B的虚拟内存和物理内存都释放回给操作系统，否则也没有释放。
>
>  
>
> 问题
>
> - 为什么malloc在小于128k时调用brk，而大于128k时调用mmap呢，为什么不全用brk或全用mmap呢
>
> ​	答：主要是为了较少内存碎片。
>
> ​	brk分配的内存只有等高地址的内存释放了低地址的内存才会释放，如果全是用brk，那么会因为内存的释放而导致产生很多内存碎片
>
> ​	mmap分配的内存是随机分配的，可能不连续，如果全用mmap的分配内存的话，会因为内存的不连续而产生很多内存碎片
>
> ​	所以使用一个折中的方法，小于128k使用brk，大于128k使用mmap
>
>  	
>
> - 为什么等到第一次访问虚拟内存的时候才分配物理内存呢
>
>   答：因为申请的内存不一定马上使用，推迟分配可以系统拥有更多的空闲物理内存去出来其他事，从而提高系统的吞吐量 
>
> - 为什么A不能释放
>
>   答：因为只有一个_edata指针，如果A释放了，_edata指针要向后退，那B内存怎么办
>
> -  为什么达到128k才释放呢
>
>    答：因为小于128k的内存并不够mmap分配，不释放，下次申请小内存时，直接重用该内存即可。
>
> ​       大于128k，可以释放该内存，以便mmap函数可以分配该内存
>
> 4、对于像vmalloc和用户进程分配内存，有没有什么方法解决内碎片
>
> 
>
> 5、测试内存的相关的实验
>
> 
>
> 6、为什么使用请求调页的方式
>
> ​	答：1）进程开始运行时并不访问其他地址空间的全部地址，有一些地址可能永远不会被进程调用（他都不被进程调用，所以干嘛要分物理内存给他呢）????（哪些线性地址不会被访问到呢）
>
> ​		2）根据程序的局部原理，真正引用的进程页只有一小部分，因此临时用不着的页所在的页框可以有其他进程来使用？？？？？（那其他页的数据怎么访问呢)
>
> ​		好处：增加了系统中空闲页框的平均数，从而更好地利用空闲内存，总体上能使系统有更大的吞吐量
>
> 7、什么叫做程序的局部性原理
>
> 答：程序的运行时，在一段时间内，程序往往呈现高度的局部性，包括时间局部性和空间局部性
>
> ​       时间局部性：一旦一个指令被执行，在不久的将来，可能还会执行
>
> ​       空间局部性：一旦一个指令和存储单元被访问，那么他附近的单元也会很快被访问
>
> 8、执行文件是怎样工作的呢？

